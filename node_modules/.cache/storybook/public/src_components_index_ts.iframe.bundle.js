(self["webpackChunkpolydomjs"] = self["webpackChunkpolydomjs"] || []).push([["src_components_index_ts"],{

/***/ "./src/components/Polygon/PolyIcon.tsx":
/*!*********************************************!*\
  !*** ./src/components/Polygon/PolyIcon.tsx ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolyIcon: () => (/* binding */ PolyIcon)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Polygon_methods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Polygon.methods */ "./src/components/Polygon/Polygon.methods.ts");
/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Polygon */ "./src/components/Polygon/Polygon.tsx");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geometry */ "./src/geometry/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");





const PolyIcon = _ref => {
  let {
    icon: Icon,
    iconPadding = 0.1,
    sides = 6,
    rotation = 0,
    strokeWidth = 0.025,
    ...polygonProps
  } = _ref;
  const dimensions = (0,_geometry__WEBPACK_IMPORTED_MODULE_3__.aspect)(sides, (0,_geometry__WEBPACK_IMPORTED_MODULE_3__.rad)(rotation));
  const apx = (0,_geometry__WEBPACK_IMPORTED_MODULE_3__.apothem)(sides, 0.5 - (strokeWidth + iconPadding));
  const difference = (0,_geometry__WEBPACK_IMPORTED_MODULE_3__.subtract)(dimensions, apx);
  const ref = (0,_Polygon_methods__WEBPACK_IMPORTED_MODULE_1__.useIcon)(Icon, apx, difference);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_Polygon__WEBPACK_IMPORTED_MODULE_2__.Polygon, {
    sides,
    rotation,
    strokeWidth,
    ...polygonProps,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("g", {
      transform: `scale(${apx * 2}) translate(${(0,_geometry__WEBPACK_IMPORTED_MODULE_3__.multiply)(dimensions, -1).join(', ')})`,
      ref: ref,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Icon, {})
    })
  });
};
PolyIcon.displayName = "PolyIcon";
try {
    // @ts-ignore
    PolyIcon.displayName = "PolyIcon";
    // @ts-ignore
    PolyIcon.__docgenInfo = { "description": "", "displayName": "PolyIcon", "props": { "icon": { "defaultValue": null, "description": "Accepts a react element however this is only been tested with react-icons and font asesome icons.", "name": "icon", "required": true, "type": { "name": "IconType" } }, "iconScaleFactor": { "defaultValue": null, "description": "This number should reflect the change in size from its original dimension. because this is a vector value it should be less then 1. values greater then 1 may have unexpected results. \ndefault is 0.8", "name": "iconScaleFactor", "required": true, "type": { "name": "number" } }, "iconPosition": { "defaultValue": null, "description": "Icon position is used to fine tune the icons location within the polygon. this will be usefull primarily with asymetric icons\nthe default is [0.2, 0.1]", "name": "iconPosition", "required": false, "type": { "name": "XY" } }, "iconPadding": { "defaultValue": { value: "0.1" }, "description": "", "name": "iconPadding", "required": false, "type": { "name": "number" } }, "sides": { "defaultValue": { value: "6" }, "description": "The number of sides the polygon has", "name": "sides", "required": false, "type": { "name": "number" } }, "rotation": { "defaultValue": { value: "0" }, "description": "the rotation angle in degrees", "name": "rotation", "required": false, "type": { "name": "number" } }, "scale": { "defaultValue": null, "description": "Scaling factor", "name": "scale", "required": false, "type": { "name": "number" } }, "cornerRadius": { "defaultValue": null, "description": "The corner radius applied to rounding each corner.", "name": "cornerRadius", "required": false, "type": { "name": "number" } }, "fill": { "defaultValue": null, "description": "The fill color", "name": "fill", "required": false, "type": { "name": "string" } }, "stroke": { "defaultValue": null, "description": "The stroke color", "name": "stroke", "required": false, "type": { "name": "string" } }, "strokeWidth": { "defaultValue": { value: "0.025" }, "description": "The stroke line width", "name": "strokeWidth", "required": false, "type": { "name": "number" } }, "width": { "defaultValue": null, "description": "The widths of the svg defaults to 100%", "name": "width", "required": false, "type": { "name": "string" } }, "height": { "defaultValue": null, "description": "The height of the svg defaults to 100%", "name": "height", "required": false, "type": { "name": "string" } }, "maskID": { "defaultValue": null, "description": "The id to be provided to the polygon mask.\nIf this is not provided a mask will not be made", "name": "maskID", "required": false, "type": { "name": "string" } }, "children": { "defaultValue": null, "description": "The children to be provided if no maskID these will be added after the polygon\nif a mask id is provided the stroke will be rendered after the children to ensure proper order", "name": "children", "required": false, "type": { "name": "ReactNode" } } } };
    // @ts-ignore
    if (typeof STORYBOOK_REACT_CLASSES !== "undefined")
        // @ts-ignore
        STORYBOOK_REACT_CLASSES["src/components/Polygon/PolyIcon.tsx#PolyIcon"] = { docgenInfo: PolyIcon.__docgenInfo, name: "PolyIcon", path: "src/components/Polygon/PolyIcon.tsx#PolyIcon" };
}
catch (__react_docgen_typescript_loader_error) { }

/***/ }),

/***/ "./src/components/Polygon/PolyImg.tsx":
/*!********************************************!*\
  !*** ./src/components/Polygon/PolyImg.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolyImg: () => (/* binding */ PolyImg)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Svg */ "./src/components/Svg/index.ts");
/* harmony import */ var _Polygon_methods__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Polygon.methods */ "./src/components/Polygon/Polygon.methods.ts");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geometry */ "./src/geometry/index.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");






const PolyImg = _ref => {
  let {
    sides = 6,
    rotation = 0,
    scale = 1,
    cornerRadius = 0,
    stroke = 'currentColor',
    strokeWidth = 0.1,
    image,
    imageScaleFactor = 1
  } = _ref;
  const [points, viewBox, scaledStrokeWidth] = (0,_Polygon_methods__WEBPACK_IMPORTED_MODULE_2__.useNgon)(sides, scale, (0,_geometry__WEBPACK_IMPORTED_MODULE_3__.rad)(rotation), cornerRadius, strokeWidth);
  console.log(viewBox);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_Svg__WEBPACK_IMPORTED_MODULE_1__.Svg, {
    viewBox: viewBox,
    width: "100%",
    height: "100%",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("defs", {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("mask", {
        id: "path-mask",
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_Svg__WEBPACK_IMPORTED_MODULE_1__.Path, {
          points,
          fill: '#fff',
          stroke: '#000',
          strokeWidth: scaledStrokeWidth
        })
      })
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("image", {
      x: viewBox[0],
      y: viewBox[1],
      width: viewBox[2] - strokeWidth,
      height: viewBox[3] - strokeWidth,
      xlinkHref: image,
      mask: "url(#path-mask)",
      transform: `scale(${imageScaleFactor})`,
      preserveAspectRatio: "xMidYMid slice"
    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_Svg__WEBPACK_IMPORTED_MODULE_1__.Path, {
      points,
      fill: 'transparent',
      stroke,
      strokeWidth: scaledStrokeWidth
    })]
  });
};
PolyImg.displayName = "PolyImg";
try {
    // @ts-ignore
    PolyImg.displayName = "PolyImg";
    // @ts-ignore
    PolyImg.__docgenInfo = { "description": "", "displayName": "PolyImg", "props": { "image": { "defaultValue": null, "description": "The image element to be provided", "name": "image", "required": true, "type": { "name": "string" } }, "imageScaleFactor": { "defaultValue": { value: "1" }, "description": "The scale factor to be used on the image. Warning values greater then 1 may cause unexpected results. If value is greater then 1 it should be expected that the image quality will be reduced.\nIt should also be noted because the image is within an SVG if the svg is scaled to large image quality will also be affected.", "name": "imageScaleFactor", "required": false, "type": { "name": "number" } }, "sides": { "defaultValue": { value: "6" }, "description": "The number of sides the polygon has", "name": "sides", "required": false, "type": { "name": "number" } }, "rotation": { "defaultValue": { value: "0" }, "description": "the rotation angle in degrees", "name": "rotation", "required": false, "type": { "name": "number" } }, "scale": { "defaultValue": { value: "1" }, "description": "Scaling factor", "name": "scale", "required": false, "type": { "name": "number" } }, "cornerRadius": { "defaultValue": { value: "0" }, "description": "The corner radius applied to rounding each corner.", "name": "cornerRadius", "required": false, "type": { "name": "number" } }, "fill": { "defaultValue": null, "description": "The fill color", "name": "fill", "required": false, "type": { "name": "string" } }, "stroke": { "defaultValue": { value: "currentColor" }, "description": "The stroke color", "name": "stroke", "required": false, "type": { "name": "string" } }, "strokeWidth": { "defaultValue": { value: "0.1" }, "description": "The stroke line width", "name": "strokeWidth", "required": false, "type": { "name": "number" } }, "width": { "defaultValue": null, "description": "The widths of the svg defaults to 100%", "name": "width", "required": false, "type": { "name": "string" } }, "height": { "defaultValue": null, "description": "The height of the svg defaults to 100%", "name": "height", "required": false, "type": { "name": "string" } }, "maskID": { "defaultValue": null, "description": "The id to be provided to the polygon mask.\nIf this is not provided a mask will not be made", "name": "maskID", "required": false, "type": { "name": "string" } }, "children": { "defaultValue": null, "description": "The children to be provided if no maskID these will be added after the polygon\nif a mask id is provided the stroke will be rendered after the children to ensure proper order", "name": "children", "required": false, "type": { "name": "ReactNode" } } } };
    // @ts-ignore
    if (typeof STORYBOOK_REACT_CLASSES !== "undefined")
        // @ts-ignore
        STORYBOOK_REACT_CLASSES["src/components/Polygon/PolyImg.tsx#PolyImg"] = { docgenInfo: PolyImg.__docgenInfo, name: "PolyImg", path: "src/components/Polygon/PolyImg.tsx#PolyImg" };
}
catch (__react_docgen_typescript_loader_error) { }

/***/ }),

/***/ "./src/components/Polygon/Polygon.methods.ts":
/*!***************************************************!*\
  !*** ./src/components/Polygon/Polygon.methods.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useIcon: () => (/* binding */ useIcon),
/* harmony export */   useNgon: () => (/* binding */ useNgon)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ "./src/geometry/index.ts");


const useNgon = (sides, scale, rotation, cornerRadius, strokeWidth) => {
  const [ssw, scr] = (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.multiply)([strokeWidth, cornerRadius], scale);
  const radius = scale / 2;
  const [cpts, vb] = (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.ngon)(sides, radius - ssw / 2, rotation, scr, [0, 0]);
  const hsw = ssw / 2;
  const bvb = (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.add)(vb, [-hsw, -hsw, ssw, ssw]);
  console.log(vb);
  //const points = translate(cpts, [-bvb[0], -bvb[1], -bvb[0], -bvb[1]])
  return [cpts, bvb, ssw];
};
const useIcon = (icon, inCircleRadius, offset) => {
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const g = ref.current;
    Array.from(g.children).forEach(elem => {
      if (elem.tagName !== 'svg') return;
      elem.removeAttribute('width');
      elem.removeAttribute('height');
      const vb = (elem.getAttribute('viewBox') ?? '0 0 0 0').split(' ').map(parseFloat);
      const maxDim = Math.max(...vb);
      const scale = inCircleRadius * 2;
      const newDim = (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.multiply)([vb[2], vb[3]], scale);
      //g.setAttribute('transform', `scale(${scale}) translate(${offset.join(' ')})`)
      console.log(vb, inCircleRadius, maxDim, scale, newDim);
    });
  }, [icon]);
  return ref;
};

/***/ }),

/***/ "./src/components/Polygon/Polygon.tsx":
/*!********************************************!*\
  !*** ./src/components/Polygon/Polygon.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Polygon: () => (/* binding */ Polygon)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ "./src/geometry/index.ts");
/* harmony import */ var _Svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Svg */ "./src/components/Svg/index.ts");
/* harmony import */ var _Polygon_methods__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Polygon.methods */ "./src/components/Polygon/Polygon.methods.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");






const Polygon = _ref => {
  let {
    sides = 6,
    rotation = 0,
    scale = 1,
    cornerRadius = 0,
    fill = '#000',
    stroke = '#000',
    strokeWidth = 0.1,
    width = '100%',
    height = '100%',
    maskID,
    children
  } = _ref;
  const [points, viewBox, scaledStrokeWidth] = (0,_Polygon_methods__WEBPACK_IMPORTED_MODULE_3__.useNgon)(sides, scale, (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.rad)(rotation), cornerRadius, strokeWidth);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(_Svg__WEBPACK_IMPORTED_MODULE_2__.Svg, {
    width,
    height,
    viewBox,
    children: [maskID ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("defs", {
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("mask", {
        id: maskID,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_Svg__WEBPACK_IMPORTED_MODULE_2__.Path, {
          points,
          fill: '#fff',
          stroke: '#000',
          strokeWidth: 0,
          scale
        })
      })
    }) : null, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_Svg__WEBPACK_IMPORTED_MODULE_2__.Path, {
      points,
      fill,
      stroke,
      strokeWidth: scaledStrokeWidth,
      scale
    }), children, children && maskID && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_Svg__WEBPACK_IMPORTED_MODULE_2__.Path, {
      points,
      fill: 'transparent',
      stroke,
      strokeWidth: scaledStrokeWidth,
      scale
    })]
  });
};
Polygon.displayName = "Polygon";
try {
    // @ts-ignore
    Polygon.displayName = "Polygon";
    // @ts-ignore
    Polygon.__docgenInfo = { "description": "", "displayName": "Polygon", "props": { "sides": { "defaultValue": { value: "6" }, "description": "The number of sides the polygon has", "name": "sides", "required": false, "type": { "name": "number" } }, "rotation": { "defaultValue": { value: "0" }, "description": "the rotation angle in degrees", "name": "rotation", "required": false, "type": { "name": "number" } }, "scale": { "defaultValue": { value: "1" }, "description": "Scaling factor", "name": "scale", "required": false, "type": { "name": "number" } }, "cornerRadius": { "defaultValue": { value: "0" }, "description": "The corner radius applied to rounding each corner.", "name": "cornerRadius", "required": false, "type": { "name": "number" } }, "fill": { "defaultValue": { value: "#000" }, "description": "The fill color", "name": "fill", "required": false, "type": { "name": "string" } }, "stroke": { "defaultValue": { value: "#000" }, "description": "The stroke color", "name": "stroke", "required": false, "type": { "name": "string" } }, "strokeWidth": { "defaultValue": { value: "0.1" }, "description": "The stroke line width", "name": "strokeWidth", "required": false, "type": { "name": "number" } }, "width": { "defaultValue": { value: "100%" }, "description": "The widths of the svg defaults to 100%", "name": "width", "required": false, "type": { "name": "string" } }, "height": { "defaultValue": { value: "100%" }, "description": "The height of the svg defaults to 100%", "name": "height", "required": false, "type": { "name": "string" } }, "maskID": { "defaultValue": null, "description": "The id to be provided to the polygon mask.\nIf this is not provided a mask will not be made", "name": "maskID", "required": false, "type": { "name": "string" } }, "children": { "defaultValue": null, "description": "The children to be provided if no maskID these will be added after the polygon\nif a mask id is provided the stroke will be rendered after the children to ensure proper order", "name": "children", "required": false, "type": { "name": "ReactNode" } } } };
    // @ts-ignore
    if (typeof STORYBOOK_REACT_CLASSES !== "undefined")
        // @ts-ignore
        STORYBOOK_REACT_CLASSES["src/components/Polygon/Polygon.tsx#Polygon"] = { docgenInfo: Polygon.__docgenInfo, name: "Polygon", path: "src/components/Polygon/Polygon.tsx#Polygon" };
}
catch (__react_docgen_typescript_loader_error) { }

/***/ }),

/***/ "./src/components/Polygon/index.ts":
/*!*****************************************!*\
  !*** ./src/components/Polygon/index.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolyIcon: () => (/* reexport safe */ _PolyIcon__WEBPACK_IMPORTED_MODULE_1__.PolyIcon),
/* harmony export */   PolyImg: () => (/* reexport safe */ _PolyImg__WEBPACK_IMPORTED_MODULE_2__.PolyImg),
/* harmony export */   Polygon: () => (/* reexport safe */ _Polygon__WEBPACK_IMPORTED_MODULE_0__.Polygon)
/* harmony export */ });
/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polygon */ "./src/components/Polygon/Polygon.tsx");
/* harmony import */ var _PolyIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PolyIcon */ "./src/components/Polygon/PolyIcon.tsx");
/* harmony import */ var _PolyImg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PolyImg */ "./src/components/Polygon/PolyImg.tsx");




/***/ }),

/***/ "./src/components/Svg/Path.tsx":
/*!*************************************!*\
  !*** ./src/components/Svg/Path.tsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* binding */ Path)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Svg_methods__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Svg.methods */ "./src/components/Svg/Svg.methods.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");



const Path = _ref => {
  let {
    points = [],
    fill,
    stroke,
    strokeWidth
  } = _ref;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("path", {
    d: (0,_Svg_methods__WEBPACK_IMPORTED_MODULE_2__.draw)(points),
    fill,
    stroke,
    strokeWidth
  });
};
Path.displayName = "Path";
try {
    // @ts-ignore
    Path.displayName = "Path";
    // @ts-ignore
    Path.__docgenInfo = { "description": "", "displayName": "Path", "props": { "points": { "defaultValue": { value: "[]" }, "description": "Renders based on points rather then string. \n2 coordinate points provided will result in a line (or movement if first point)\n4 coordinate points provided will result in a cubic curve", "name": "points", "required": false, "type": { "name": "number[][]" } }, "fill": { "defaultValue": null, "description": "The fill color", "name": "fill", "required": false, "type": { "name": "string" } }, "stroke": { "defaultValue": null, "description": "The stroke color", "name": "stroke", "required": false, "type": { "name": "string" } }, "strokeWidth": { "defaultValue": null, "description": "The stroke width", "name": "strokeWidth", "required": false, "type": { "name": "number" } }, "scale": { "defaultValue": null, "description": "scale will allow path to adjust border size", "name": "scale", "required": false, "type": { "name": "number" } } } };
    // @ts-ignore
    if (typeof STORYBOOK_REACT_CLASSES !== "undefined")
        // @ts-ignore
        STORYBOOK_REACT_CLASSES["src/components/Svg/Path.tsx#Path"] = { docgenInfo: Path.__docgenInfo, name: "Path", path: "src/components/Svg/Path.tsx#Path" };
}
catch (__react_docgen_typescript_loader_error) { }

/***/ }),

/***/ "./src/components/Svg/Svg.methods.ts":
/*!*******************************************!*\
  !*** ./src/components/Svg/Svg.methods.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   draw: () => (/* binding */ draw)
/* harmony export */ });
/**
 * creats a paths draw string
 * @param param0 
 * @returns string
 */
const draw = _ref => {
  let [f, ...points] = _ref;
  return !f ? '' : `M ${f.join(' ')}` + points.map(v => `${v.length == 2 ? 'L' : 'Q'} ${v.join(' ')}`).join(' ') + ' Z';
};

/***/ }),

/***/ "./src/components/Svg/Svg.tsx":
/*!************************************!*\
  !*** ./src/components/Svg/Svg.tsx ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Svg: () => (/* binding */ Svg)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");


const Svg = _ref => {
  let {
    viewBox = [0, 0, 0, 0],
    width,
    height,
    children,
    preserveAspectRatio = 'xMidYMid meet'
  } = _ref;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("svg", {
    viewBox: viewBox.join(' '),
    xmlns: "http://www.w3.org/2000/svg",
    width,
    height,
    preserveAspectRatio,
    children: children
  });
};
Svg.displayName = "Svg";
try {
    // @ts-ignore
    Svg.displayName = "Svg";
    // @ts-ignore
    Svg.__docgenInfo = { "description": "", "displayName": "Svg", "props": { "viewBox": { "defaultValue": { value: "[0, 0, 0, 0]" }, "description": "The view box this will be converted to a string", "name": "viewBox", "required": false, "type": { "name": "Cubic" } }, "width": { "defaultValue": null, "description": "The width element of the svg element", "name": "width", "required": false, "type": { "name": "string" } }, "height": { "defaultValue": null, "description": "The height element of the svg element", "name": "height", "required": false, "type": { "name": "string" } }, "children": { "defaultValue": null, "description": "The children accepts any react node... user beware html inside svg can have unexpected results.", "name": "children", "required": false, "type": { "name": "ReactNode" } }, "preserveAspectRatio": { "defaultValue": { value: "xMidYMid meet" }, "description": "", "name": "preserveAspectRatio", "required": false, "type": { "name": "string" } } } };
    // @ts-ignore
    if (typeof STORYBOOK_REACT_CLASSES !== "undefined")
        // @ts-ignore
        STORYBOOK_REACT_CLASSES["src/components/Svg/Svg.tsx#Svg"] = { docgenInfo: Svg.__docgenInfo, name: "Svg", path: "src/components/Svg/Svg.tsx#Svg" };
}
catch (__react_docgen_typescript_loader_error) { }

/***/ }),

/***/ "./src/components/Svg/index.ts":
/*!*************************************!*\
  !*** ./src/components/Svg/index.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* reexport safe */ _Path__WEBPACK_IMPORTED_MODULE_1__.Path),
/* harmony export */   Svg: () => (/* reexport safe */ _Svg__WEBPACK_IMPORTED_MODULE_0__.Svg)
/* harmony export */ });
/* harmony import */ var _Svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Svg */ "./src/components/Svg/Svg.tsx");
/* harmony import */ var _Path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Path */ "./src/components/Svg/Path.tsx");



/***/ }),

/***/ "./src/components/index.ts":
/*!*********************************!*\
  !*** ./src/components/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolyIcon: () => (/* reexport safe */ _Polygon__WEBPACK_IMPORTED_MODULE_0__.PolyIcon),
/* harmony export */   PolyImg: () => (/* reexport safe */ _Polygon__WEBPACK_IMPORTED_MODULE_0__.PolyImg),
/* harmony export */   Polygon: () => (/* reexport safe */ _Polygon__WEBPACK_IMPORTED_MODULE_0__.Polygon)
/* harmony export */ });
/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polygon */ "./src/components/Polygon/index.ts");


/***/ }),

/***/ "./src/geometry/geometry.methods.ts":
/*!******************************************!*\
  !*** ./src/geometry/geometry.methods.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   apothem: () => (/* binding */ apothem),
/* harmony export */   aspect: () => (/* binding */ aspect),
/* harmony export */   calc: () => (/* binding */ calc),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   edge: () => (/* binding */ edge),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   measure: () => (/* binding */ measure),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   ngon: () => (/* binding */ ngon),
/* harmony export */   operators: () => (/* binding */ operators),
/* harmony export */   rad: () => (/* binding */ rad),
/* harmony export */   ray: () => (/* binding */ ray),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   uniform: () => (/* binding */ uniform)
/* harmony export */ });
/**
 * cast a ray from a particular point at a specified angle and distance. 
 * @param angle 
 * @param radius 
 * @param center 
 * @returns XY
 */
const ray = function (angle) {
  let radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  let center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];
  return [Math.cos(angle) * radius + center[0], Math.sin(angle) * radius + center[1]];
};

/**
 * Create the points to generate an ngon
 * @param sides 
 * @param radius 
 * @param center 
 * @returns XY[]
 */
const ngon = function (sides, radius, rotation, cornerRadius) {
  let center = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];
  const radian = 2 * Math.PI / sides;
  const interiorRadian = Math.PI * (sides - 2) / sides / 2;
  let points = [];
  let minP = [0, 0];
  let maxP = [0, 0];
  for (let i = 0; i < sides; i++) {
    const angle = radian * i + rotation;
    const p = ray(angle, radius, center);
    if (cornerRadius > 0) {
      const inverseAngle = invert(angle);
      const p1 = ray(inverseAngle + interiorRadian, cornerRadius, p);
      const p2 = ray(inverseAngle - interiorRadian, cornerRadius, p);
      points = [...points, p1, [...p, ...p2]];
    } else {
      points.push(p);
    }
    minP = min(minP, p);
    maxP = max(maxP, p);
  }
  return [points, [...minP, ...multiply(maxP, 2)]];
};

/**
 * Just a convenience method to create radians from degrees
 * @param deg 
 * @returns radians
 */
const rad = deg => deg * (Math.PI / 180);

/**
 * Returns a cubic [minX minY, distanceX, distanceY]
 * @param points 
 */
const measure = points => {
  let minP = [0, 0];
  let maxP = [0, 0];
  for (let i = 0; i < points.length; i++) {
    minP = min(minP, points[i]);
  }
  return [...minP, ...multiply(maxP, 2)];
};

/**
 * Finds the minimum values in the two provided XY coordinates
 * @param p1 
 * @param p2 
 * @returns 
 */
const min = (p1, p2) => [Math.min(p1[0], p2[0]), Math.min(p1[1], p2[1])];

/**
 * Finds the miximum values in the two provided XY coordinates
 * @param p1 
 * @param p2 
 * @returns 
 */
const max = (p1, p2) => [Math.max(p1[0], p2[0]), Math.max(p1[1], p2[1])];

//MARK mathematical operators
const operators = {
  '+': (a, b) => a + b,
  '-': (a, b) => a - b,
  '*': (a, b) => a * b,
  '/': (a, b) => a / b
};

/**
 * A generalized mathematical operator method. This will replicate SIMD operation. I say replicate because SIMD is not possible using javascript as such I do not want to have addition tech debt utilizing the SIMD package. 
 * if b is provided as an array it should be equal in length to a otherwise an error will be thrown.
 */
const calc = (operator, a, b) => {
  const bRay = typeof b === 'number' ? new Array(a.length).fill(b) : b;
  if (a.length > bRay.length) throw new Error(`Unable to perform ${operator} on items due to mismatched length: A:${a.length} B:${bRay.length}`);
  return a.map((v, i) => operators[operator](v, bRay[i]));
};
/**
 * Multiply a point by another point or by a singular number
 * @param point 
 * @param multiplier 
 * @returns 
 */
const multiply = (point, multiplier) => calc('*', point, multiplier);
const add = (point, additor) => calc('+', point, additor);
const divide = (a, b) => calc('/', a, b);
const subtract = (a, b) => calc('-', a, b);

/**
 * translates a point. b should be no less the the largest possible coordinate provided currently this is Cubic
 * @param a 
 * @param b 
 * @returns 
 */
const translate = (a, b) => a.map(v => add(v, b));
/**
 * Invert the current angle
 * @param angle 
 * @returns 
 */
const invert = angle => Math.PI + angle;

/**
 * Create a coordinate array with all coodinate points having the same number
 * @param value 
 * @param length 
 * @returns 
 */
const uniform = (value, length) => new Array(length).fill(value);

/**
 * return the width and height. the return value will be 2 coordinate points between 0 and 1
 * @param sides 
 */
const aspect = (sides, rotation) => {
  let dim = [0, 0];
  const angle = 2 * Math.PI / sides;
  for (let i = 0; i < sides; i++) {
    dim = max(dim, ray(angle * i + rotation, 0.5));
  }
  return dim;
};

/**
 * return the side length based on the number of sides and a circum radius assumed to be 0.5 i.e 1 total size
 * @param sides
 * @returns number
 */
const edge = (sides, length) => 2 * length * Math.sin(Math.PI / sides);
const apothem = (sides, length) => edge(sides, length) / (2 * Math.tan(Math.PI / sides));

/***/ }),

/***/ "./src/geometry/geometry.types.ts":
/*!****************************************!*\
  !*** ./src/geometry/geometry.types.ts ***!
  \****************************************/
/***/ (() => {



/***/ }),

/***/ "./src/geometry/index.ts":
/*!*******************************!*\
  !*** ./src/geometry/index.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.add),
/* harmony export */   apothem: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.apothem),
/* harmony export */   aspect: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.aspect),
/* harmony export */   calc: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.calc),
/* harmony export */   divide: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.divide),
/* harmony export */   edge: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.edge),
/* harmony export */   invert: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.invert),
/* harmony export */   max: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.max),
/* harmony export */   measure: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.measure),
/* harmony export */   min: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.min),
/* harmony export */   multiply: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.multiply),
/* harmony export */   ngon: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.ngon),
/* harmony export */   operators: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.operators),
/* harmony export */   rad: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.rad),
/* harmony export */   ray: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.ray),
/* harmony export */   subtract: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.subtract),
/* harmony export */   translate: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.translate),
/* harmony export */   uniform: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.uniform)
/* harmony export */ });
/* harmony import */ var _geometry_methods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.methods */ "./src/geometry/geometry.methods.ts");
/* harmony import */ var _geometry_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometry.types */ "./src/geometry/geometry.types.ts");
/* harmony import */ var _geometry_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_geometry_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _geometry_types__WEBPACK_IMPORTED_MODULE_1__) if(["default","add","apothem","aspect","calc","divide","edge","invert","max","measure","min","multiply","ngon","operators","rad","ray","subtract","translate","uniform"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _geometry_types__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);



/***/ })

}]);
//# sourceMappingURL=src_components_index_ts.iframe.bundle.js.map