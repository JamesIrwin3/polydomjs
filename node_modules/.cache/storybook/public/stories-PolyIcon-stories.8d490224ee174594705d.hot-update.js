"use strict";
self["webpackHotUpdatepolydomjs"]("stories-PolyIcon-stories",{

/***/ "./src/geometry/geometry.methods.ts":
/*!******************************************!*\
  !*** ./src/geometry/geometry.methods.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   calc: () => (/* binding */ calc),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   measure: () => (/* binding */ measure),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   ngon: () => (/* binding */ ngon),
/* harmony export */   operators: () => (/* binding */ operators),
/* harmony export */   rad: () => (/* binding */ rad),
/* harmony export */   ray: () => (/* binding */ ray),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   uniform: () => (/* binding */ uniform)
/* harmony export */ });
/**
 * cast a ray from a particular point at a specified angle and distance. 
 * @param angle 
 * @param radius 
 * @param center 
 * @returns XY
 */
const ray = (angle, radius, center) => [Math.cos(angle) * radius + center[0], Math.sin(angle) * radius + center[1]];

/**
 * Create the points to generate an ngon
 * @param sides 
 * @param radius 
 * @param center 
 * @returns XY[]
 */
const ngon = function (sides, radius, rotation, cornerRadius) {
  let center = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];
  const radian = 2 * Math.PI / sides;
  const interiorRadian = Math.PI * (sides - 2) / sides / 2;
  let points = [];
  let minP = [0, 0];
  let maxP = [0, 0];
  for (let i = 0; i < sides; i++) {
    const angle = radian * i + rotation;
    const p = ray(angle, radius, center);
    if (cornerRadius > 0) {
      const inverseAngle = invert(angle);
      const p1 = ray(inverseAngle + interiorRadian, cornerRadius, p);
      const p2 = ray(inverseAngle - interiorRadian, cornerRadius, p);
      points = [...points, p1, [...p, ...p2]];
    } else {
      points.push(p);
    }
    minP = min(minP, p);
    maxP = max(maxP, p);
  }
  return [points, [...minP, ...multiply(maxP, 2)]];
};

/**
 * Just a convenience method to create radians from degrees
 * @param deg 
 * @returns radians
 */
const rad = deg => deg * (Math.PI / 180);

/**
 * Returns a cubic [minX minY, distanceX, distanceY]
 * @param points 
 */
const measure = points => {
  let minP = [0, 0];
  let maxP = [0, 0];
  for (let i = 0; i < points.length; i++) {
    minP = min(minP, points[i]);
  }
  return [...minP, ...multiply(maxP, 2)];
};

/**
 * Finds the minimum values in the two provided XY coordinates
 * @param p1 
 * @param p2 
 * @returns 
 */
const min = (p1, p2) => [Math.min(p1[0], p2[0]), Math.min(p1[1], p2[1])];

/**
 * Finds the miximum values in the two provided XY coordinates
 * @param p1 
 * @param p2 
 * @returns 
 */
const max = (p1, p2) => [Math.max(p1[0], p2[0]), Math.max(p1[1], p2[1])];

//MARK mathematical operators
const operators = {
  '+': (a, b) => a + b,
  '-': (a, b) => a - b,
  '*': (a, b) => a * b,
  '/': (a, b) => a / b
};

/**
 * A generalized mathematical operator method. This will replicate SIMD operation. I say replicate because SIMD is not possible using javascript as such I do not want to have addition tech debt utilizing the SIMD package. 
 * if b is provided as an array it should be equal in length to a otherwise an error will be thrown.
 */
const calc = (operator, a, b) => {
  const bRay = typeof b === 'number' ? new Array(a.length).fill(b) : b;
  if (a.length !== bRay.length) throw new Error(`Unable to perform ${operator} on items due to mismatched length: A:${a.length} B:${bRay.length}`);
  return a.map((v, i) => operators[operator](v, bRay[i]));
};
/**
 * Multiply a point by another point or by a singular number
 * @param point 
 * @param multiplier 
 * @returns 
 */
const multiply = (point, multiplier) => calc('*', point, multiplier);
const add = (point, additor) => calc('+', point, additor);
const divide = (a, b) => calc('/', a, b);
const subtract = (a, b) => calc('-', a, b);

/**
 * Invert the current angle
 * @param angle 
 * @returns 
 */
const invert = angle => Math.PI + angle;

/**
 * Create a coordinate array with all coodinate points having the same number
 * @param value 
 * @param length 
 * @returns 
 */
const uniform = (value, length) => new Array(length).fill(value);

/***/ })

});
//# sourceMappingURL=stories-PolyIcon-stories.8d490224ee174594705d.hot-update.js.map