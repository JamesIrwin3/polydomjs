"use strict";
self["webpackHotUpdatepolydomjs"]("stories-Polygon-stories",{

/***/ "./src/geometry/geometry.methods.ts":
/*!******************************************!*\
  !*** ./src/geometry/geometry.methods.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   measure: () => (/* binding */ measure),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   ngon: () => (/* binding */ ngon),
/* harmony export */   rad: () => (/* binding */ rad),
/* harmony export */   ray: () => (/* binding */ ray)
/* harmony export */ });
/**
 * cast a ray from a particular point at a specified angle and distance. 
 * @param angle 
 * @param radius 
 * @param center 
 * @returns XY
 */
const ray = (angle, radius, center) => [Math.cos(angle) * radius + center[0], Math.sin(angle) * radius + center[1]];

/**
 * Create the points to generate an ngon
 * @param sides 
 * @param radius 
 * @param center 
 * @returns XY[]
 */
const ngon = function (sides, radius, rotation) {
  let center = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 0];
  const radian = 2 * Math.PI / sides;
  let points = [];
  let minP = [0, 0];
  let maxP = [0, 0];
  for (let i = 0; i < sides; i++) {
    const p = ray(radian * i + rotation, radius, center);
    minP = min(minP, p);
    maxP = max(maxP, p);
    points.push(p);
  }
  return;
};

/**
 * Just a convenience method to create radians from degrees
 * @param deg 
 * @returns radians
 */
const rad = deg => deg * (Math.PI / 180);

/**
 * Returns a cubic [minX minY, distanceX, distanceY]
 * @param points 
 */
const measure = points => {
  let minP = [0, 0];
  let maxP = [0, 0];
  for (let i = 0; i < points.length; i++) {
    minP = min(minP, points[i]);
  }
  return [...minP, ...multiply(maxP, 2)];
};
const min = (p1, p2) => [Math.min(p1[0], p2[0]), Math.min(p1[1], p2[1])];
const max = (p1, p2) => [Math.max(p1[0], p2[0]), Math.max(p1[1], p2[1])];
const multiply = (point, multiplier) => {
  const mult = typeof multiplier === 'number' ? new Array(2).fill(multiplier) : multiplier;
  return point.map((v, i) => v * mult[i]);
};

/***/ })

});
//# sourceMappingURL=stories-Polygon-stories.9b0db651d9cfb474fa65.hot-update.js.map