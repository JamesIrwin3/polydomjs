self["webpackHotUpdatepolydomjs"]("stories-Polygon-stories",{

/***/ "./src/components/Polygon/Polygon.methods.ts":
/*!***************************************************!*\
  !*** ./src/components/Polygon/Polygon.methods.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useNgon: () => (/* binding */ useNgon)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ "./src/geometry/index.ts");


const useNgon = (sides, scale, rotation, cornerRadius, strokeWidth) => {
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    sides,
    scale,
    rotation,
    cornerRadius,
    strokeWidth
  });
  const radius = state.scale / 2;
  const [cpts, vb] = (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.ngon)(state.sides, radius, state.rotation, state.cornerRadius, [0, 0]);
  const ssw = state.strokeWidth * scale;
  const hsw = ssw / 2;
  const nvb = (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.add)((0,_geometry__WEBPACK_IMPORTED_MODULE_1__.multiply)(vb, -1), hsw);
  const points = (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.translate)(cpts, [nvb[0], nvb[1], nvb[0], nvb[1]]);
  const maxBound = (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.multiply)((0,_geometry__WEBPACK_IMPORTED_MODULE_1__.add)([vb[2], vb[3]], hsw), 2);
  const viewBox = [0, 0, ...maxBound];
  return [points, viewBox, ssw, setState];
};

/***/ }),

/***/ "./src/components/Polygon/Polygon.tsx":
/*!********************************************!*\
  !*** ./src/components/Polygon/Polygon.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Polygon: () => (/* binding */ Polygon)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ "./src/geometry/index.ts");
/* harmony import */ var _Svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Svg */ "./src/components/Svg/index.ts");
/* harmony import */ var _Polygon_methods__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Polygon.methods */ "./src/components/Polygon/Polygon.methods.ts");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");





const Polygon = _ref => {
  let {
    sides = 6,
    rotation = 0,
    scale = 1,
    cornerRadius = 0,
    fill = '#000',
    stroke = '#000',
    strokeWidth = 0.1
  } = _ref;
  const [points, viewBox, scaledStrokeWidth] = (0,_Polygon_methods__WEBPACK_IMPORTED_MODULE_3__.useNgon)(sides, scale, rotation, cornerRadius, strokeWidth);
  const scaledLineWidth = strokeWidth * scale;
  const hl = scaledLineWidth > 0 ? scaledLineWidth / 2 : 0;
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_Svg__WEBPACK_IMPORTED_MODULE_2__.Svg, {
    viewBox: [...(0,_geometry__WEBPACK_IMPORTED_MODULE_1__.subtract)([viewBox[0], viewBox[1]], hl), ...(0,_geometry__WEBPACK_IMPORTED_MODULE_1__.add)([viewBox[2], viewBox[3]], scaledLineWidth)],
    width: "100px",
    height: "100px",
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_Svg__WEBPACK_IMPORTED_MODULE_2__.Path, {
      points,
      fill,
      stroke,
      strokeWidth: scaledStrokeWidth,
      scale
    })
  });
};
Polygon.displayName = "Polygon";
try {
    // @ts-ignore
    Polygon.displayName = "Polygon";
    // @ts-ignore
    Polygon.__docgenInfo = { "description": "", "displayName": "Polygon", "props": { "sides": { "defaultValue": { value: "6" }, "description": "The number of sides the polygon has", "name": "sides", "required": false, "type": { "name": "number" } }, "rotation": { "defaultValue": { value: "0" }, "description": "the rotation angle in degrees", "name": "rotation", "required": false, "type": { "name": "number" } }, "scale": { "defaultValue": { value: "1" }, "description": "Scaling factor", "name": "scale", "required": false, "type": { "name": "number" } }, "cornerRadius": { "defaultValue": { value: "0" }, "description": "The corner radius applied to rounding each corner.", "name": "cornerRadius", "required": false, "type": { "name": "number" } }, "fill": { "defaultValue": { value: "#000" }, "description": "The fill color", "name": "fill", "required": false, "type": { "name": "string" } }, "stroke": { "defaultValue": { value: "#000" }, "description": "The stroke color", "name": "stroke", "required": false, "type": { "name": "string" } }, "strokeWidth": { "defaultValue": { value: "0.1" }, "description": "The stroke line width", "name": "strokeWidth", "required": false, "type": { "name": "number" } } } };
    // @ts-ignore
    if (typeof STORYBOOK_REACT_CLASSES !== "undefined")
        // @ts-ignore
        STORYBOOK_REACT_CLASSES["src/components/Polygon/Polygon.tsx#Polygon"] = { docgenInfo: Polygon.__docgenInfo, name: "Polygon", path: "src/components/Polygon/Polygon.tsx#Polygon" };
}
catch (__react_docgen_typescript_loader_error) { }

/***/ }),

/***/ "./src/components/Polygon/index.ts":
/*!*****************************************!*\
  !*** ./src/components/Polygon/index.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Polygon: () => (/* reexport safe */ _Polygon__WEBPACK_IMPORTED_MODULE_0__.Polygon)
/* harmony export */ });
/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polygon */ "./src/components/Polygon/Polygon.tsx");


/***/ }),

/***/ "./src/components/index.ts":
/*!*********************************!*\
  !*** ./src/components/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolyIcon: () => (/* reexport safe */ _PolyIcon__WEBPACK_IMPORTED_MODULE_1__.PolyIcon),
/* harmony export */   Polygon: () => (/* reexport safe */ _Polygon__WEBPACK_IMPORTED_MODULE_0__.Polygon)
/* harmony export */ });
/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polygon */ "./src/components/Polygon/index.ts");
/* harmony import */ var _PolyIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PolyIcon */ "./src/components/PolyIcon/index.ts");



/***/ }),

/***/ "./src/geometry/geometry.methods.ts":
/*!******************************************!*\
  !*** ./src/geometry/geometry.methods.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   calc: () => (/* binding */ calc),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   measure: () => (/* binding */ measure),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   ngon: () => (/* binding */ ngon),
/* harmony export */   operators: () => (/* binding */ operators),
/* harmony export */   rad: () => (/* binding */ rad),
/* harmony export */   ray: () => (/* binding */ ray),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   uniform: () => (/* binding */ uniform)
/* harmony export */ });
/**
 * cast a ray from a particular point at a specified angle and distance. 
 * @param angle 
 * @param radius 
 * @param center 
 * @returns XY
 */
const ray = (angle, radius, center) => [Math.cos(angle) * radius + center[0], Math.sin(angle) * radius + center[1]];

/**
 * Create the points to generate an ngon
 * @param sides 
 * @param radius 
 * @param center 
 * @returns XY[]
 */
const ngon = function (sides, radius, rotation, cornerRadius) {
  let center = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];
  const radian = 2 * Math.PI / sides;
  const interiorRadian = Math.PI * (sides - 2) / sides / 2;
  let points = [];
  let minP = [0, 0];
  let maxP = [0, 0];
  for (let i = 0; i < sides; i++) {
    const angle = radian * i + rotation;
    const p = ray(angle, radius, center);
    if (cornerRadius > 0) {
      const inverseAngle = invert(angle);
      const p1 = ray(inverseAngle + interiorRadian, cornerRadius, p);
      const p2 = ray(inverseAngle - interiorRadian, cornerRadius, p);
      points = [...points, p1, [...p, ...p2]];
    } else {
      points.push(p);
    }
    minP = min(minP, p);
    maxP = max(maxP, p);
  }
  return [points, [...minP, ...multiply(maxP, 2)]];
};

/**
 * Just a convenience method to create radians from degrees
 * @param deg 
 * @returns radians
 */
const rad = deg => deg * (Math.PI / 180);

/**
 * Returns a cubic [minX minY, distanceX, distanceY]
 * @param points 
 */
const measure = points => {
  let minP = [0, 0];
  let maxP = [0, 0];
  for (let i = 0; i < points.length; i++) {
    minP = min(minP, points[i]);
  }
  return [...minP, ...multiply(maxP, 2)];
};

/**
 * Finds the minimum values in the two provided XY coordinates
 * @param p1 
 * @param p2 
 * @returns 
 */
const min = (p1, p2) => [Math.min(p1[0], p2[0]), Math.min(p1[1], p2[1])];

/**
 * Finds the miximum values in the two provided XY coordinates
 * @param p1 
 * @param p2 
 * @returns 
 */
const max = (p1, p2) => [Math.max(p1[0], p2[0]), Math.max(p1[1], p2[1])];

//MARK mathematical operators
const operators = {
  '+': (a, b) => a + b,
  '-': (a, b) => a - b,
  '*': (a, b) => a * b,
  '/': (a, b) => a / b
};

/**
 * A generalized mathematical operator method. This will replicate SIMD operation. I say replicate because SIMD is not possible using javascript as such I do not want to have addition tech debt utilizing the SIMD package. 
 * if b is provided as an array it should be equal in length to a otherwise an error will be thrown.
 */
const calc = (operator, a, b) => {
  const bRay = typeof b === 'number' ? new Array(a.length).fill(b) : b;
  if (a.length > bRay.length) throw new Error(`Unable to perform ${operator} on items due to mismatched length: A:${a.length} B:${bRay.length}`);
  return a.map((v, i) => operators[operator](v, bRay[i]));
};
/**
 * Multiply a point by another point or by a singular number
 * @param point 
 * @param multiplier 
 * @returns 
 */
const multiply = (point, multiplier) => calc('*', point, multiplier);
const add = (point, additor) => calc('+', point, additor);
const divide = (a, b) => calc('/', a, b);
const subtract = (a, b) => calc('-', a, b);

/**
 * translates a point. b should be no less the the largest possible coordinate provided currently this is Cubic
 * @param a 
 * @param b 
 * @returns 
 */
const translate = (a, b) => a.map(v => add(v, b));
/**
 * Invert the current angle
 * @param angle 
 * @returns 
 */
const invert = angle => Math.PI + angle;

/**
 * Create a coordinate array with all coodinate points having the same number
 * @param value 
 * @param length 
 * @returns 
 */
const uniform = (value, length) => new Array(length).fill(value);

/***/ }),

/***/ "./src/geometry/geometry.types.ts":
/*!****************************************!*\
  !*** ./src/geometry/geometry.types.ts ***!
  \****************************************/
/***/ (() => {



/***/ }),

/***/ "./src/geometry/index.ts":
/*!*******************************!*\
  !*** ./src/geometry/index.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.add),
/* harmony export */   calc: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.calc),
/* harmony export */   divide: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.divide),
/* harmony export */   invert: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.invert),
/* harmony export */   max: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.max),
/* harmony export */   measure: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.measure),
/* harmony export */   min: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.min),
/* harmony export */   multiply: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.multiply),
/* harmony export */   ngon: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.ngon),
/* harmony export */   operators: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.operators),
/* harmony export */   rad: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.rad),
/* harmony export */   ray: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.ray),
/* harmony export */   subtract: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.subtract),
/* harmony export */   translate: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.translate),
/* harmony export */   uniform: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.uniform)
/* harmony export */ });
/* harmony import */ var _geometry_methods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.methods */ "./src/geometry/geometry.methods.ts");
/* harmony import */ var _geometry_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometry.types */ "./src/geometry/geometry.types.ts");
/* harmony import */ var _geometry_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_geometry_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _geometry_types__WEBPACK_IMPORTED_MODULE_1__) if(["default","add","calc","divide","invert","max","measure","min","multiply","ngon","operators","rad","ray","subtract","translate","uniform"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _geometry_types__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);



/***/ })

});
//# sourceMappingURL=stories-Polygon-stories.11f2f99d4972c235a1b4.hot-update.js.map