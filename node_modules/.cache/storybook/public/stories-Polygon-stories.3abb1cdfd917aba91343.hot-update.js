self["webpackHotUpdatepolydomjs"]("stories-Polygon-stories",{

/***/ "./src/components/Polygon/Polygon.tsx":
/*!********************************************!*\
  !*** ./src/components/Polygon/Polygon.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Polygon: () => (/* binding */ Polygon)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _svg_svg_methods__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../svg/svg.methods */ "./src/svg/svg.methods.ts");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ "./src/geometry/index.ts");
/* harmony import */ var react_icons_fa__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-icons/fa */ "./node_modules/react-icons/fa/index.esm.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");






const Polygon = _ref => {
  let {
    sides = 6,
    rotation = 0,
    scale = 1,
    cornerRadius = 0,
    fillColor = '#000',
    strokeColor = '#000',
    lineWidth = 0.1,
    children = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_icons_fa__WEBPACK_IMPORTED_MODULE_3__.FaBeer, {})
  } = _ref;
  const [points, viewBox] = (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.ngon)(sides, scale, (0,_geometry__WEBPACK_IMPORTED_MODULE_1__.rad)(rotation), cornerRadius, [0, 0]);
  const scaledLineWidth = lineWidth * scale;
  const hl = scaledLineWidth > 0 ? scaledLineWidth / 2 : 0;
  const newViewBox = [viewBox[0] - hl, viewBox[1] - hl, viewBox[2] + scaledLineWidth, viewBox[3] + scaledLineWidth];
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const knownPath = ref.current;
    if (!children) return;
    const nextChild = knownPath.nextSibling;
    console.log(nextChild);
    if (nextChild.tagName === 'svg') {
      const childViewBox = nextChild.getAttribute('viewBox')?.split(' ').map(v => parseFloat(v));
      console.log("do something with this", childViewBox);
    }
  }, []);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: newViewBox.join(' '),
    width: "100px",
    height: "100px",
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("path", {
      d: (0,_svg_svg_methods__WEBPACK_IMPORTED_MODULE_4__.draw)(points),
      ref: ref,
      fill: fillColor,
      stroke: strokeColor,
      strokeWidth: scaledLineWidth
    }), children]
  });
};
Polygon.displayName = "Polygon";
try {
    // @ts-ignore
    Polygon.displayName = "Polygon";
    // @ts-ignore
    Polygon.__docgenInfo = { "description": "", "displayName": "Polygon", "props": { "sides": { "defaultValue": { value: "6" }, "description": "The number of sides the polygon has", "name": "sides", "required": false, "type": { "name": "number" } }, "rotation": { "defaultValue": { value: "0" }, "description": "the rotation angle in degrees", "name": "rotation", "required": false, "type": { "name": "number" } }, "scale": { "defaultValue": { value: "1" }, "description": "Scaling factor", "name": "scale", "required": false, "type": { "name": "number" } }, "cornerRadius": { "defaultValue": { value: "0" }, "description": "The corner radius applied to rounding each corner.", "name": "cornerRadius", "required": false, "type": { "name": "number" } }, "fillColor": { "defaultValue": { value: "#000" }, "description": "The fill color", "name": "fillColor", "required": false, "type": { "name": "string" } }, "strokeColor": { "defaultValue": { value: "#000" }, "description": "The stroke color", "name": "strokeColor", "required": false, "type": { "name": "string" } }, "lineWidth": { "defaultValue": { value: "0.1" }, "description": "The stroke line width", "name": "lineWidth", "required": false, "type": { "name": "number" } }, "children": { "defaultValue": { value: "<FaBeer/>" }, "description": "The children to be added. \n\nIt is important to note that these children will be placed within an SVG. \nif a svg is provided as a child for example an icon. The component will attempt to adopt the viewbox of the child svg", "name": "children", "required": false, "type": { "name": "ReactNode" } } } };
    // @ts-ignore
    if (typeof STORYBOOK_REACT_CLASSES !== "undefined")
        // @ts-ignore
        STORYBOOK_REACT_CLASSES["src/components/Polygon/Polygon.tsx#Polygon"] = { docgenInfo: Polygon.__docgenInfo, name: "Polygon", path: "src/components/Polygon/Polygon.tsx#Polygon" };
}
catch (__react_docgen_typescript_loader_error) { }

/***/ }),

/***/ "./src/geometry/geometry.methods.ts":
/*!******************************************!*\
  !*** ./src/geometry/geometry.methods.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   measure: () => (/* binding */ measure),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   ngon: () => (/* binding */ ngon),
/* harmony export */   operators: () => (/* binding */ operators),
/* harmony export */   rad: () => (/* binding */ rad),
/* harmony export */   ray: () => (/* binding */ ray)
/* harmony export */ });
/**
 * cast a ray from a particular point at a specified angle and distance. 
 * @param angle 
 * @param radius 
 * @param center 
 * @returns XY
 */
const ray = (angle, radius, center) => [Math.cos(angle) * radius + center[0], Math.sin(angle) * radius + center[1]];

/**
 * Create the points to generate an ngon
 * @param sides 
 * @param radius 
 * @param center 
 * @returns XY[]
 */
const ngon = function (sides, radius, rotation, cornerRadius) {
  let center = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0, 0];
  const radian = 2 * Math.PI / sides;
  const interiorRadian = Math.PI * (sides - 2) / sides / 2;
  let points = [];
  let minP = [0, 0];
  let maxP = [0, 0];
  for (let i = 0; i < sides; i++) {
    const angle = radian * i + rotation;
    const p = ray(angle, radius, center);
    if (cornerRadius > 0) {
      const inverseAngle = invert(angle);
      const p1 = ray(inverseAngle + interiorRadian, cornerRadius, p);
      const p2 = ray(inverseAngle - interiorRadian, cornerRadius, p);
      points = [...points, p1, [...p, ...p2]];
    } else {
      points.push(p);
    }
    minP = min(minP, p);
    maxP = max(maxP, p);
  }
  return [points, [...minP, ...multiply(maxP, 2)]];
};

/**
 * Just a convenience method to create radians from degrees
 * @param deg 
 * @returns radians
 */
const rad = deg => deg * (Math.PI / 180);

/**
 * Returns a cubic [minX minY, distanceX, distanceY]
 * @param points 
 */
const measure = points => {
  let minP = [0, 0];
  let maxP = [0, 0];
  for (let i = 0; i < points.length; i++) {
    minP = min(minP, points[i]);
  }
  return [...minP, ...multiply(maxP, 2)];
};

/**
 * Finds the minimum values in the two provided XY coordinates
 * @param p1 
 * @param p2 
 * @returns 
 */
const min = (p1, p2) => [Math.min(p1[0], p2[0]), Math.min(p1[1], p2[1])];

/**
 * Finds the miximum values in the two provided XY coordinates
 * @param p1 
 * @param p2 
 * @returns 
 */
const max = (p1, p2) => [Math.max(p1[0], p2[0]), Math.max(p1[1], p2[1])];

//MARK mathematical operators
const operators = {
  '+': (a, b) => a + b,
  '-': (a, b) => a - b,
  '*': (a, b) => a * b,
  '/': (a, b) => a / b
};

/**
 * Multiply a point by another point or by a singular number
 * @param point 
 * @param multiplier 
 * @returns 
 */
const multiply = (point, multiplier) => {
  const mult = typeof multiplier === 'number' ? new Array(point.length).fill(multiplier) : multiplier;
  if (mult.length !== point.length) throw `Unable to multiply non parallel arrays ${point.length} ${mult.length}`;
  return point.map((v, i) => v * mult[i]);
};
const add = (point, additor) => {
  const additing = typeof additor === 'number' ? new Array(point.length).fill(additor) : additor;
  if (additing.length !== point.length) throw `Unable to add non parallel arrays ${point.length} ${additing.length}`;
  return point.map((v, i) => v * additing[i]);
};

/**
 * Invert the current angle
 * @param angle 
 * @returns 
 */
const invert = angle => Math.PI + angle;

/***/ }),

/***/ "./src/geometry/geometry.types.ts":
/*!****************************************!*\
  !*** ./src/geometry/geometry.types.ts ***!
  \****************************************/
/***/ (() => {



/***/ }),

/***/ "./src/geometry/index.ts":
/*!*******************************!*\
  !*** ./src/geometry/index.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.add),
/* harmony export */   invert: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.invert),
/* harmony export */   max: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.max),
/* harmony export */   measure: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.measure),
/* harmony export */   min: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.min),
/* harmony export */   multiply: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.multiply),
/* harmony export */   ngon: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.ngon),
/* harmony export */   operators: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.operators),
/* harmony export */   rad: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.rad),
/* harmony export */   ray: () => (/* reexport safe */ _geometry_methods__WEBPACK_IMPORTED_MODULE_0__.ray)
/* harmony export */ });
/* harmony import */ var _geometry_methods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.methods */ "./src/geometry/geometry.methods.ts");
/* harmony import */ var _geometry_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometry.types */ "./src/geometry/geometry.types.ts");
/* harmony import */ var _geometry_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_geometry_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _geometry_types__WEBPACK_IMPORTED_MODULE_1__) if(["default","add","invert","max","measure","min","multiply","ngon","operators","rad","ray"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _geometry_types__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);



/***/ })

});
//# sourceMappingURL=stories-Polygon-stories.3abb1cdfd917aba91343.hot-update.js.map